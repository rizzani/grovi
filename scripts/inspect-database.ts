import { Client, Databases } from "appwrite";
import * as dotenv from "dotenv";
import * as path from "path";
import * as fs from "fs";
import * as https from "https";
import * as http from "http";

// Load environment variables from .env file
const envPath = path.join(process.cwd(), ".env");
if (fs.existsSync(envPath)) {
  dotenv.config({ path: envPath });
} else {
  // Try .env.local as fallback
  const envLocalPath = path.join(process.cwd(), ".env.local");
  if (fs.existsSync(envLocalPath)) {
    dotenv.config({ path: envLocalPath });
  }
}

// Get environment variables
const endpoint = process.env.EXPO_PUBLIC_APPWRITE_ENDPOINT || "";
const projectId = process.env.EXPO_PUBLIC_APPWRITE_PROJECT_ID || "";
const apiKey = process.env.APPWRITE_API_KEY || "";
const databaseId = process.env.APPWRITE_DATABASE_ID || "grovi-db";

if (!endpoint || !projectId || !apiKey) {
  console.error("Missing required environment variables:");
  console.error("  EXPO_PUBLIC_APPWRITE_ENDPOINT:", endpoint ? "‚úì" : "‚úó");
  console.error("  EXPO_PUBLIC_APPWRITE_PROJECT_ID:", projectId ? "‚úì" : "‚úó");
  console.error("  APPWRITE_API_KEY:", apiKey ? "‚úì" : "‚úó");
  process.exit(1);
}

// Helper function to make API requests to Appwrite
async function appwriteRequest(
  method: string,
  path: string,
  body?: any
): Promise<any> {
  return new Promise((resolve, reject) => {
    // Ensure endpoint ends with /v1 if not already present
    const baseUrl = endpoint.endsWith("/v1") ? endpoint : `${endpoint}/v1`;
    const fullUrl = `${baseUrl}${path}`;
    const url = new URL(fullUrl);
    const isHttps = url.protocol === "https:";
    const httpModule = isHttps ? https : http;

    const postData = body ? JSON.stringify(body) : undefined;

    const options = {
      hostname: url.hostname,
      port: url.port || (isHttps ? 443 : 80),
      path: url.pathname + url.search,
      method,
      headers: {
        "Content-Type": "application/json",
        "X-Appwrite-Project": projectId,
        "X-Appwrite-Key": apiKey,
      },
    };

    const req = httpModule.request(options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        try {
          const parsed = data ? JSON.parse(data) : {};
          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            resolve(parsed);
          } else {
            const error: any = new Error(parsed.message || "Request failed");
            error.code = res.statusCode;
            error.response = parsed;
            reject(error);
          }
        } catch (e) {
          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            resolve(data);
          } else {
            reject(new Error(`Request failed with status ${res.statusCode}`));
          }
        }
      });
    });

    req.on("error", (error) => {
      reject(error);
    });

    if (postData) {
      req.write(postData);
    }

    req.end();
  });
}

// Initialize Appwrite client
const client = new Client().setEndpoint(endpoint).setProject(projectId);
const databases = new Databases(client);

interface CollectionInfo {
  id: string;
  name: string;
  attributes: any[];
  indexes: any[];
  permissions: any[];
  documentCount?: number;
  sampleDocuments?: any[];
  performanceMetrics?: {
    attributesFetchTime: number;
    indexesFetchTime: number;
    documentsFetchTime: number;
  };
  dataQuality?: {
    totalChecked: number;
    emptyRequiredFields: Array<{ field: string; count: number }>;
    invalidData: Array<{ field: string; issue: string; count: number }>;
  };
}

interface PreviousReport {
  timestamp: string;
  databaseId: string;
  collections: Array<{
    id: string;
    name: string;
    documentCount: number;
    attributeCount: number;
    indexCount: number;
  }>;
}

// Report builder to capture output for markdown file
class ReportBuilder {
  private lines: string[] = [];
  private structuredData: any = {};

  log(message: string = "") {
    console.log(message);
    this.lines.push(message);
  }

  setStructuredData(data: any) {
    this.structuredData = data;
  }

  getReport(): string {
    return this.lines.join("\n");
  }

  getMarkdownReport(): string {
    const timestamp = new Date().toISOString();
    return `# Database Inspection Report

**Generated:** ${timestamp}  
**Database ID:** ${databaseId}

---

${this.lines.join("\n")}

---

*Report auto-generated by \`scripts/inspect-database.ts\`*
`;
  }

  getStructuredData(): any {
    return this.structuredData;
  }
}

// Load previous report for comparison
function loadPreviousReport(): PreviousReport | null {
  try {
    const jsonPath = path.join(process.cwd(), ".database-report.json");
    if (fs.existsSync(jsonPath)) {
      const data = fs.readFileSync(jsonPath, "utf-8");
      return JSON.parse(data);
    }
  } catch (error) {
    // Ignore errors, just return null
  }
  return null;
}

// Save structured data for next comparison
function saveStructuredReport(data: any) {
  try {
    const jsonPath = path.join(process.cwd(), ".database-report.json");
    fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2), "utf-8");
  } catch (error) {
    console.error("Warning: Could not save structured report:", error);
  }
}

// Validate data quality for a collection
function validateDataQuality(
  collectionId: string,
  attributes: any[],
  documents: any[]
): {
  totalChecked: number;
  emptyRequiredFields: Array<{ field: string; count: number }>;
  invalidData: Array<{ field: string; issue: string; count: number }>;
} {
  const emptyRequiredFields: Map<string, number> = new Map();
  const invalidData: Array<{ field: string; issue: string; count: number }> = [];

  const requiredAttrs = attributes.filter((attr) => attr.required);

  documents.forEach((doc) => {
    requiredAttrs.forEach((attr) => {
      const value = doc[attr.key];
      if (value === null || value === undefined || value === "") {
        const count = emptyRequiredFields.get(attr.key) || 0;
        emptyRequiredFields.set(attr.key, count + 1);
      }
    });

    // Check for specific data integrity issues
    if (collectionId === "products") {
      // Check if price-related fields are valid
      if (doc.price !== undefined && (doc.price < 0 || isNaN(doc.price))) {
        const existing = invalidData.find(
          (i) => i.field === "price" && i.issue === "negative or invalid"
        );
        if (existing) {
          existing.count++;
        } else {
          invalidData.push({
            field: "price",
            issue: "negative or invalid",
            count: 1,
          });
        }
      }
    }

    if (collectionId === "store_location_product") {
      if (
        doc.price_jmd_cents !== undefined &&
        (doc.price_jmd_cents < 0 || isNaN(doc.price_jmd_cents))
      ) {
        const existing = invalidData.find(
          (i) =>
            i.field === "price_jmd_cents" && i.issue === "negative or invalid"
        );
        if (existing) {
          existing.count++;
        } else {
          invalidData.push({
            field: "price_jmd_cents",
            issue: "negative or invalid",
            count: 1,
          });
        }
      }
    }
  });

  return {
    totalChecked: documents.length,
    emptyRequiredFields: Array.from(emptyRequiredFields.entries()).map(
      ([field, count]) => ({ field, count })
    ),
    invalidData,
  };
}

// Validate relationships between collections
async function validateRelationships(
  collectionInfos: CollectionInfo[],
  report: ReportBuilder
): Promise<void> {
  report.log(`\n\n${"=".repeat(60)}`);
  report.log("üîó RELATIONSHIP INTEGRITY CHECK");
  report.log(`${"=".repeat(60)}\n`);

  const collectionMap = new Map(
    collectionInfos.map((info) => [info.id, info])
  );

  // Check store_location_product relationships
  const slpInfo = collectionMap.get("store_location_product");
  const productsInfo = collectionMap.get("products");
  const storeLocationInfo = collectionMap.get("store_location");
  const storeBrandInfo = collectionMap.get("store_brand");

  if (slpInfo && slpInfo.sampleDocuments && slpInfo.sampleDocuments.length > 0) {
    report.log("Checking store_location_product relationships...");

    const sampleDocs = slpInfo.sampleDocuments;
    let orphanedProducts = 0;
    let orphanedStores = 0;
    let orphanedBrands = 0;

    for (const doc of sampleDocs) {
      // Check if product_id exists
      if (
        doc.product_id &&
        productsInfo &&
        productsInfo.sampleDocuments
      ) {
        const productExists = productsInfo.sampleDocuments.some(
          (p: any) => p.$id === doc.product_id
        );
        if (!productExists) {
          try {
            await databases.getDocument(databaseId, "products", doc.product_id);
          } catch (error) {
            orphanedProducts++;
          }
        }
      }

      // Check if store_location_id exists
      if (doc.store_location_id && storeLocationInfo) {
        try {
          await databases.getDocument(
            databaseId,
            "store_location",
            doc.store_location_id
          );
        } catch (error) {
          orphanedStores++;
        }
      }

      // Check if brand_id exists
      if (doc.brand_id && storeBrandInfo) {
        try {
          await databases.getDocument(databaseId, "store_brand", doc.brand_id);
        } catch (error) {
          orphanedBrands++;
        }
      }
    }

    if (orphanedProducts === 0 && orphanedStores === 0 && orphanedBrands === 0) {
      report.log(
        `‚úì All relationships valid (checked ${sampleDocs.length} samples)`
      );
    } else {
      if (orphanedProducts > 0) {
        report.log(
          `‚ö†Ô∏è  Found ${orphanedProducts} orphaned product references (in sample)`
        );
      }
      if (orphanedStores > 0) {
        report.log(
          `‚ö†Ô∏è  Found ${orphanedStores} orphaned store location references (in sample)`
        );
      }
      if (orphanedBrands > 0) {
        report.log(
          `‚ö†Ô∏è  Found ${orphanedBrands} orphaned brand references (in sample)`
        );
      }
    }
    report.log("");
  } else {
    report.log("‚ö†Ô∏è  Cannot validate relationships: insufficient data\n");
  }

  // Check products -> categories relationship
  if (productsInfo && productsInfo.sampleDocuments) {
    const categoriesInfo = collectionMap.get("categories");
    if (categoriesInfo) {
      report.log("Checking products -> categories relationships...");
      let orphanedCategories = 0;

      for (const product of productsInfo.sampleDocuments.slice(0, 10)) {
        if (product.category_leaf_id) {
          try {
            await databases.getDocument(
              databaseId,
              "categories",
              product.category_leaf_id
            );
          } catch (error) {
            orphanedCategories++;
          }
        }
      }

      if (orphanedCategories === 0) {
        report.log("‚úì All product category references valid");
      } else {
        report.log(
          `‚ö†Ô∏è  Found ${orphanedCategories} orphaned category references (in sample)`
        );
      }
      report.log("");
    }
  }
}

async function inspectDatabase() {
  const report = new ReportBuilder();
  const startTime = Date.now();
  
  try {
    report.log("üîç Inspecting Appwrite Database...\n");
    report.log(`Database ID: ${databaseId}\n`);

    // Load previous report for comparison
    const previousReport = loadPreviousReport();
    if (previousReport) {
      report.log(
        `üìä Comparing with previous report from ${new Date(previousReport.timestamp).toLocaleString()}\n`
      );
    }

    // Step 1: Get all collections
    report.log("üì¶ Fetching collections...");
    let collections;
    const collectionsStart = Date.now();
    try {
      const response = await appwriteRequest(
        "GET",
        `/databases/${databaseId}/collections`
      );
      collections = response.collections || [];
      const collectionsTime = Date.now() - collectionsStart;
      report.log(
        `‚úì Found ${collections.length} collection(s) (${collectionsTime}ms)\n`
      );
    } catch (error: any) {
      report.log(`‚úó Failed to fetch collections: ${error.message}`);
      return;
    }

    if (collections.length === 0) {
      report.log("No collections found in database.\n");
      return;
    }

    // Step 2: Inspect each collection
    const collectionInfos: CollectionInfo[] = [];

    for (const collection of collections) {
      report.log(`\n${"=".repeat(60)}`);
      report.log(`Collection: ${collection.name} (${collection.$id})`);
      report.log(`${"=".repeat(60)}`);

      const info: CollectionInfo = {
        id: collection.$id,
        name: collection.name,
        attributes: [],
        indexes: [],
        permissions: collection.$permissions || [],
      };

      info.performanceMetrics = {
        attributesFetchTime: 0,
        indexesFetchTime: 0,
        documentsFetchTime: 0,
      };

      // Get attributes
      try {
        const attrStart = Date.now();
        const attrsResponse = await appwriteRequest(
          "GET",
          `/databases/${databaseId}/collections/${collection.$id}/attributes`
        );
        info.performanceMetrics.attributesFetchTime = Date.now() - attrStart;
        info.attributes = attrsResponse.attributes || [];
        report.log(
          `\nüìã Attributes (${info.attributes.length}) [${info.performanceMetrics.attributesFetchTime}ms]:`
        );
        info.attributes.forEach((attr: any) => {
          const type = attr.type || "unknown";
          const required = attr.required ? "required" : "optional";
          const array = attr.array ? "array" : "";
          report.log(
            `  - ${attr.key}: ${type}${array ? `[${array}]` : ""} (${required})`
          );
        });
      } catch (error: any) {
        report.log(`  ‚úó Failed to fetch attributes: ${error.message}`);
      }

      // Get indexes
      try {
        const idxStart = Date.now();
        const indexesResponse = await appwriteRequest(
          "GET",
          `/databases/${databaseId}/collections/${collection.$id}/indexes`
        );
        info.performanceMetrics.indexesFetchTime = Date.now() - idxStart;
        info.indexes = indexesResponse.indexes || [];
        report.log(
          `\nüîç Indexes (${info.indexes.length}) [${info.performanceMetrics.indexesFetchTime}ms]:`
        );
        if (info.indexes.length === 0) {
          report.log("  (no indexes)");
        } else {
          info.indexes.forEach((idx: any) => {
            const attrs = idx.attributes?.join(", ") || "unknown";
            const type = idx.type || "unknown";
            report.log(`  - ${idx.key}: ${type} on [${attrs}]`);
          });
        }
      } catch (error: any) {
        report.log(`  ‚úó Failed to fetch indexes: ${error.message}`);
      }

      // Get document count and sample documents
      try {
        const docsStart = Date.now();
        const docsResponse = await databases.listDocuments(
          databaseId,
          collection.$id,
          []
        );
        info.performanceMetrics.documentsFetchTime = Date.now() - docsStart;
        info.documentCount = docsResponse.total;
        info.sampleDocuments = docsResponse.documents.slice(0, 10); // Get 10 for quality checks

        report.log(
          `\nüìÑ Documents: ${info.documentCount} [${info.performanceMetrics.documentsFetchTime}ms]`
        );

        // Data quality check
        if (info.sampleDocuments.length > 0) {
          const quality = validateDataQuality(
            collection.$id,
            info.attributes,
            info.sampleDocuments
          );
          info.dataQuality = quality;

          if (
            quality.emptyRequiredFields.length > 0 ||
            quality.invalidData.length > 0
          ) {
            report.log(`\n‚ö†Ô∏è  Data Quality Issues (checked ${quality.totalChecked} documents):`);
            quality.emptyRequiredFields.forEach((item) => {
              report.log(
                `  - Empty required field '${item.field}': ${item.count} occurrences`
              );
            });
            quality.invalidData.forEach((item) => {
              report.log(
                `  - Invalid '${item.field}' (${item.issue}): ${item.count} occurrences`
              );
            });
          } else {
            report.log(
              `\n‚úì Data Quality: Good (checked ${quality.totalChecked} documents)`
            );
          }

          report.log(`\nüìù Sample document structure:`);
          const sample = info.sampleDocuments[0];
          Object.keys(sample).forEach((key) => {
            const value = sample[key];
            const type = Array.isArray(value)
              ? "array"
              : typeof value === "object" && value !== null
              ? "object"
              : typeof value;
            const preview =
              typeof value === "string"
                ? value.length > 50
                  ? value.substring(0, 50) + "..."
                  : value
                : Array.isArray(value)
                ? `[${value.length} items]`
                : value;
            report.log(`  - ${key}: ${type} = ${preview}`);
          });
        }
      } catch (error: any) {
        report.log(`\nüìÑ Documents: Unable to fetch (${error.message})`);
      }

      collectionInfos.push(info);
    }

    // Step 3: Summary report for search requirements
    report.log(`\n\n${"=".repeat(60)}`);
    report.log("üîé SEARCH REQUIREMENTS CHECK");
    report.log(`${"=".repeat(60)}\n`);

    const requiredCollections = [
      "products",
      "brands",
      "categories",
      "store_locations",
      "store_location_product",
    ];

    const collectionMap = new Map(
      collectionInfos.map((info) => [info.id, info])
    );

    requiredCollections.forEach((collectionId) => {
      const info = collectionMap.get(collectionId);
      if (info) {
        report.log(`‚úì ${collectionId}: EXISTS`);
        report.log(`  - Attributes: ${info.attributes.length}`);
        report.log(`  - Indexes: ${info.indexes.length}`);
        report.log(`  - Documents: ${info.documentCount || 0}`);

        // Check for specific requirements
        if (collectionId === "products") {
          const hasName = info.attributes.some(
            (attr: any) => attr.key === "name"
          );
          const hasSku = info.attributes.some((attr: any) => attr.key === "sku");
          report.log(`  - Has 'name' attribute: ${hasName ? "‚úì" : "‚úó"}`);
          report.log(`  - Has 'sku' attribute: ${hasSku ? "‚úì" : "‚úó"}`);
          const hasFullTextIndex = info.indexes.some(
            (idx: any) => idx.type === "fulltext" && idx.attributes?.includes("name")
          );
          report.log(
            `  - Has full-text index on 'name': ${hasFullTextIndex ? "‚úì" : "‚úó (recommended)"}`
          );
        }

        if (collectionId === "brands") {
          const hasName = info.attributes.some(
            (attr: any) => attr.key === "name"
          );
          report.log(`  - Has 'name' attribute: ${hasName ? "‚úì" : "‚úó"}`);
          const hasFullTextIndex = info.indexes.some(
            (idx: any) => idx.type === "fulltext" && idx.attributes?.includes("name")
          );
          report.log(
            `  - Has full-text index on 'name': ${hasFullTextIndex ? "‚úì" : "‚úó (recommended)"}`
          );
        }

        if (collectionId === "categories") {
          const hasName = info.attributes.some(
            (attr: any) => attr.key === "name"
          );
          report.log(`  - Has 'name' attribute: ${hasName ? "‚úì" : "‚úó"}`);
          const hasFullTextIndex = info.indexes.some(
            (idx: any) => idx.type === "fulltext" && idx.attributes?.includes("name")
          );
          report.log(
            `  - Has full-text index on 'name': ${hasFullTextIndex ? "‚úì" : "‚úó (recommended)"}`
          );
        }

        if (collectionId === "store_locations") {
          const hasActive = info.attributes.some(
            (attr: any) => attr.key === "active"
          );
          report.log(`  - Has 'active' attribute: ${hasActive ? "‚úì" : "‚úó"}`);
          const hasActiveIndex = info.indexes.some(
            (idx: any) =>
              idx.attributes?.includes("active") || idx.key?.includes("active")
          );
          report.log(
            `  - Has index on 'active': ${hasActiveIndex ? "‚úì" : "‚úó (recommended)"}`
          );
        }

        if (collectionId === "store_location_product") {
          const requiredAttrs = [
            "product_id",
            "store_location_id",
            "brand_id",
            "in_stock",
            "price_jmd_cents",
          ];
          requiredAttrs.forEach((attr) => {
            const hasAttr = info.attributes.some(
              (a: any) => a.key === attr
            );
            report.log(`  - Has '${attr}' attribute: ${hasAttr ? "‚úì" : "‚úó"}`);
          });

          const recommendedIndexes = [
            "idx_in_stock",
            "idx_store_stock",
            "idx_brand",
            "idx_category_leaf",
          ];
          recommendedIndexes.forEach((idxKey) => {
            const hasIdx = info.indexes.some((idx: any) => idx.key === idxKey);
            report.log(
              `  - Has '${idxKey}' index: ${hasIdx ? "‚úì" : "‚úó (recommended)"}`
            );
          });
        }
        report.log("");
      } else {
        report.log(`‚úó ${collectionId}: MISSING\n`);
      }
    });

    // Step 4: Generate recommendations
    report.log(`\n${"=".repeat(60)}`);
    report.log("üí° RECOMMENDATIONS");
    report.log(`${"=".repeat(60)}\n`);

    const missingCollections = requiredCollections.filter(
      (id) => !collectionMap.has(id)
    );

    if (missingCollections.length > 0) {
      report.log("Missing collections that need to be created:");
      missingCollections.forEach((id) => {
        report.log(`  - ${id}`);
      });
      report.log("");
    }

    // Check for missing full-text indexes
    const needsFullTextIndex = ["products", "brands", "categories"];
    needsFullTextIndex.forEach((collectionId) => {
      const info = collectionMap.get(collectionId);
      if (info) {
        const hasFullTextIndex = info.indexes.some(
          (idx: any) => idx.type === "fulltext" && idx.attributes?.includes("name")
        );
        if (!hasFullTextIndex) {
          report.log(
            `‚ö†Ô∏è  ${collectionId}: Consider adding full-text index on 'name' for better search performance`
          );
        }
      }
    });

    // Step 5: Validate relationships
    await validateRelationships(collectionInfos, report);

    // Step 6: Performance Summary
    report.log(`\n${"=".repeat(60)}`);
    report.log("‚ö° PERFORMANCE SUMMARY");
    report.log(`${"=".repeat(60)}\n`);

    const totalTime = Date.now() - startTime;
    let totalApiTime = 0;
    collectionInfos.forEach((info) => {
      if (info.performanceMetrics) {
        totalApiTime +=
          info.performanceMetrics.attributesFetchTime +
          info.performanceMetrics.indexesFetchTime +
          info.performanceMetrics.documentsFetchTime;
      }
    });

    report.log(`Total inspection time: ${totalTime}ms (${(totalTime / 1000).toFixed(2)}s)`);
    report.log(`Total API request time: ${totalApiTime}ms`);
    report.log(`Average per collection: ${Math.round(totalApiTime / collectionInfos.length)}ms`);

    const slowCollections = collectionInfos
      .filter((info) => {
        if (!info.performanceMetrics) return false;
        const total =
          info.performanceMetrics.attributesFetchTime +
          info.performanceMetrics.indexesFetchTime +
          info.performanceMetrics.documentsFetchTime;
        return total > 1000;
      })
      .map((info) => ({
        name: info.name,
        time:
          (info.performanceMetrics?.attributesFetchTime || 0) +
          (info.performanceMetrics?.indexesFetchTime || 0) +
          (info.performanceMetrics?.documentsFetchTime || 0),
      }))
      .sort((a, b) => b.time - a.time);

    if (slowCollections.length > 0) {
      report.log(`\n‚ö†Ô∏è  Slow collections (>1000ms):`);
      slowCollections.forEach((col) => {
        report.log(`  - ${col.name}: ${col.time}ms`);
      });
    } else {
      report.log(`\n‚úì All collections performing well (<1000ms)`);
    }

    // Step 7: Compare with previous report
    if (previousReport) {
      report.log(`\n\n${"=".repeat(60)}`);
      report.log("üìà CHANGES SINCE LAST INSPECTION");
      report.log(`${"=".repeat(60)}\n`);

      const prevCollectionMap = new Map(
        previousReport.collections.map((c) => [c.id, c])
      );

      const newCollections = collectionInfos.filter(
        (info) => !prevCollectionMap.has(info.id)
      );
      const removedCollections = previousReport.collections.filter(
        (c) => !collectionInfos.find((info) => info.id === c.id)
      );

      if (newCollections.length > 0) {
        report.log(`‚ú® New collections (${newCollections.length}):`);
        newCollections.forEach((info) => {
          report.log(`  + ${info.name} (${info.id})`);
        });
        report.log("");
      }

      if (removedCollections.length > 0) {
        report.log(`üóëÔ∏è  Removed collections (${removedCollections.length}):`);
        removedCollections.forEach((c) => {
          report.log(`  - ${c.name} (${c.id})`);
        });
        report.log("");
      }

      // Check for changes in existing collections
      const changes: string[] = [];
      collectionInfos.forEach((info) => {
        const prev = prevCollectionMap.get(info.id);
        if (prev) {
          const docChange = (info.documentCount || 0) - prev.documentCount;
          const attrChange = info.attributes.length - prev.attributeCount;
          const indexChange = info.indexes.length - prev.indexCount;

          if (docChange !== 0 || attrChange !== 0 || indexChange !== 0) {
            let changeStr = `  ${info.name}:`;
            if (docChange !== 0) {
              changeStr += ` ${docChange > 0 ? "+" : ""}${docChange} docs`;
            }
            if (attrChange !== 0) {
              changeStr += ` ${attrChange > 0 ? "+" : ""}${attrChange} attrs`;
            }
            if (indexChange !== 0) {
              changeStr += ` ${indexChange > 0 ? "+" : ""}${indexChange} indexes`;
            }
            changes.push(changeStr);
          }
        }
      });

      if (changes.length > 0) {
        report.log(`üìä Collection changes:`);
        changes.forEach((change) => report.log(change));
      } else if (
        newCollections.length === 0 &&
        removedCollections.length === 0
      ) {
        report.log(`‚úì No changes detected`);
      }
      report.log("");
    }

    report.log("\n‚úÖ Inspection complete!\n");

    // Prepare structured data for next comparison
    const structuredData = {
      timestamp: new Date().toISOString(),
      databaseId,
      collections: collectionInfos.map((info) => ({
        id: info.id,
        name: info.name,
        documentCount: info.documentCount || 0,
        attributeCount: info.attributes.length,
        indexCount: info.indexes.length,
      })),
    };

    report.setStructuredData(structuredData);

    // Save reports
    const reportPath = path.join(process.cwd(), "DATABASE_REPORT.md");
    const markdownReport = report.getMarkdownReport();
    fs.writeFileSync(reportPath, markdownReport, "utf-8");
    saveStructuredReport(structuredData);
    console.log(`üìÑ Report saved to: ${reportPath}`);
    console.log(`üìä Comparison data saved for next run\n`);
  } catch (error: any) {
    const errorMsg = `\n‚ùå Database inspection failed: ${error.message}`;
    console.error(errorMsg);
    if (error.response) {
      console.error("Response:", JSON.stringify(error.response, null, 2));
    }
    process.exit(1);
  }
}

// Run the inspection
inspectDatabase();
